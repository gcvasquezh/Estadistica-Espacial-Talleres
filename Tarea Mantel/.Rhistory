library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_pib,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#### Varios modelos la mismo tiempo
ajuste_final_models<-diff_tsibble%>%model(
`Fourier1pibdiff`=ARIMA(logdiff_pib~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier2pibdiff`=ARIMA(logdiff_pib~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier3pibdiff`=ARIMA(logdiff_pib~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`DummyPIBdiff`=ARIMA(logdiff_pib~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#### Varios modelos la mismo tiempo
ajuste_final_models<-diff_tsibble%>%model(
`Fourier1pibdiff`=ARIMA(logdiff_PIB~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier2pibdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier3pibdiff`=ARIMA(logdiff_PIB~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
glance(ajuste_final_models)
ajuste_final_models %>%
select(Fourier1pibdiff)%>%coef()
Modelo_serie_diff_models<-diff_tsibble%>%left_join(fitted(ajuste_final_models)|>group_by(.model)%>%
pivot_wider(names_from = .model, values_from = .fitted))
Modelo_serie_diff_models %>%
autoplot() +
geom_line(data=Modelo_serie_diff_models,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier1pibdiff,colour="ajustadoFourier1"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier2pibdiff,colour="ajustadoFourier2"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier3pibdiff,colour="ajustadoFourier3"))+
geom_line(data=Modelo_serie_diff_models,aes(y=DummyPIBdiff,colour="ajustadoDummy")) +
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustadoFourier1" = "red","ajustadoFourier2" = "blue","ajustadoFourier3"="green","ajustadoDummy"="yellow"))
STLextra<-PIB3TS-smooth_vec(PIB3TS,span = 0.1, degree = 2)
library(plotly)
library(forecast)
library(MASS)
library(tidyverse)
library(lubridate)
library(timetk)
library(tibble)
library(zoo)
library(tsibble)
library(feasts)
library(fable)
library(cowplot)
library(astsa)
library(TSstudio)
library(fabletools)
library(TSA)
library(readxl)
PIB3 <- read_excel("C:/Users/ander/OneDrive - Universidad Nacional de Colombia/Documentos/(2024-01) Octavo Semestre/Series de Tiempo Univariadas/Proyecto/1.4 PIB_Precios constantes grandes ramas de actividades economicas_trimestral_V2.xlsx", range = "AS18:AS93", col_names = FALSE)
PIB3TS <- ts(PIB3, start = c(2005, 1), end = c(2023, 4), frequency = 4)
#Convirtiendo los datos originales en objeto serie de tiempo(ts)
plot_ly( x = time(PIB3TS), y = PIB3TS, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral en Colombia',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
acf(PIB3TS,lag.max = length(PIB3TS))
Lambda<-BoxCox.lambda(PIB3TS, method ="loglik", lower = -3, upper = 3)#Encontrando el valor de Lambda
Lambda
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))9
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))9
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50)))
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))
summary(fitLM <- lm(PIB3TS~time(PIB3TS), na.action=NULL))#Creando un modelo de regresión lineal
plot(PIB3TS, ylab="PIB trimestral en Colombia",xlab="Trimestre")
abline(fitLM,col = "red")
PIB3NoLM=PIB3TS-predict(fitLM)#Eliminando la tendencia
plot_ly( x = time(PIB3NoLM), y = PIB3NoLM, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB trimestral en Colombia con tendencia lineal extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
indice1=as.Date(as.yearmon(tk_index(PIB3TS)))#Convirtiendo en fecha el indice de DesempleoTSBox, deja como primero de enero cada fecha
indice1.1=yearmon(as.yearmon(tk_index(PIB3TS)))#Dejando esa fecha solo como año y mes
## Haciendo el objeto tsibble
df=data.frame(Fecha=indice1,PIB=as.matrix(PIB3TS))
colnames(df)[2]<-"PIB"
PIB3TSibble=as_tsibble(df)
PIB3TSibble
pib3TSibble <- tsibble(
periodo = seq(as.Date("2005-01-01"), as.Date("2023-12-01"), by = "3 months"),
valor = PIB3
)
####Primera aproximación del ajuste STL
df%>%timetk::plot_time_series(Fecha, PIB,
.interactive = TRUE,
.plotly_slider = TRUE)
#Creando una nueva columna con los datos ajustados por una regresión STL de grado 2 y utilizando el 20% de los datos, entre más pequeño, la curva es menos suave
###Ajuste STL moviendo los parámetros
df%>%mutate(PIBmod=smooth_vec(PIB,span = 0.1, degree = 2))%>%
ggplot(aes(Fecha, PIB)) +
geom_line() +
geom_line(aes(y = PIBmod), color = "red")
STLextra<-PIB3TS-smooth_vec(PIB3TS,span = 0.1, degree = 2)
plot_ly( x = time(STLextra), y = STLextra, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral con tendencia STL extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
tsibblePIB<-as_tsibble(PIB3TS)#Creando el objeto tsibble del PIB
tsibblePIB
tsibblePIB %>%
model(
STL(value ~ trend() +
season(window = "periodic"),
robust = TRUE)) %>%
components() %>%
autoplot()
DiferenciaOrd<-diff(PIB3TS)
plot_ly( x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB sin tendencia(Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
DiferenciaOrd<-diff(PIB3TS)
plot_ly( x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB sin tendencia(Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
# Carga la biblioteca
library(gstat)
library(readr)
temp <- read.csv("C:/Users/ander/Downloads", sep=",",header=T)
library(reaxl)
temp <- read_excel("C:/Users/ander/Downloads", sep=",",header=T)
library(readxl)
temp <- read_excel("C:/Users/ander/Downloads", sep=",",header=T)
temp <- read_excel("C:/Users/ander/Downloads")
library(geoR)
library (gstat)
library(MASS)
library(ade4)
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid)
distancia<-dist(grid)
distancia<-as.matrix(distancia)
View(grid)
View(distancia)
coordenadas<-cbind(c(1,1,1,2,2,3,3),c(1,2,3,1,3,2,3),c(12,15,10,14,NA,12,NA,14,13))
View(coordenadas)
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas)
variograma<-2.81*(1-exp(-distancia/2))
covariogramaa<-var(na.omit(coordenadas$Datos))-variograma
View(coordenadas)
covariogramaa<-var(na.omit(coordenadas$data))-variograma
View(covariogramaa)
covariograma<-var(na.omit(coordenadas$data))-variograma
View(covariograma)
# Matriz C_ij
C.ij<-covariograma[-c(3,5),-c(3,5)]
# Vector C_i0
C.i0<-covariograma[-c(3,5),5]
# Pesos lambda
lambda<-ginv(C.ij)%*%C.i0
# Datos sin los NA's
datossin<-datos[-c(3,5)]
# Estimación
t(lambda)%*%datossin
library(geoR)
library (gstat)
library(MASS)
library(ade4)
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid)
distancia<-dist(grid)
distancia<-as.matrix(distancia)
coordenadas<-cbind(c(1,1,1,2,2,3,3),c(1,2,3,1,3,2,3),c(12,15,10,14,NA,12,NA,14,13))
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas1 <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas1)
View(coordenadas)
variograma<-2.81*(1-exp(-distancia/2))
covariograma<-var(na.omit(coordenadas$Datos))-variograma
View(coordenadas)
covariograma<-var(na.omit(coordenadas[,3]))-variograma
View(covariograma)
# Matriz C_ij
C.ij<-covariograma[-c(3,5),-c(3,5)]
# Vector C_i0
C.i0<-covariograma[-c(3,5),5]
# Pesos lambda
lambda<-ginv(C.ij)%*%C.i0
# Datos sin los NA's
datossin<-coordenadas[-c(3,5)]
# Estimación
t(lambda)%*%datossin
# Datos sin los NA's
datossin<-coordenadas%Datos[-c(3,5)]
# Datos sin los NA's
datossin<-coordenadas$Datos[-c(3,5)]
# Datos sin los NA's
datossin<-coordenadas[,3][-c(3,5)]
# Estimación
t(lambda)%*%datossin
library(geoR)
library (gstat)
library(MASS)
library(ade4)
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid)
distancia<-dist(grid)
distancia<-as.matrix(distancia)
coordenadas<-cbind(c(1,1,1,2,2,3,3),c(1,2,3,1,3,2,3),c(12,15,10,14,NA,12,NA,14,13))
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas)
variograma<-2.81*(1-exp(-distancia/2))
covariograma<-var(na.omit(coordenadas$data))-variograma
# Matriz C_ij
C.ij<-covariograma[-c(3,5),-c(3,5)]
# Vector C_i0
C.i0<-covariograma[-c(3,5),5]
# Pesos lambda
lambda<-ginv(C.ij)%*%C.i0
# Datos sin los NA's
datossin<-coordenadas$data[-c(3,5)]
# Estimación
t(lambda)%*%datossin
View(grid)
datos <- c(12,14,NA,15,NA,14,10,12,13)
coordenadas<-cbind(grid[,1],grid[,2],datos)
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas)
library(geoR)
library (gstat)
library(MASS)
library(ade4)
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid)
distancia<-dist(grid)
distancia<-as.matrix(distancia)
datos <- c(12,14,NA,15,NA,14,10,12,13)
coordenadas<-cbind(grid[,1],grid[,2],datos)
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas)
variograma<-2.81*(1-exp(-distancia/2))
covariograma<-var(na.omit(coordenadas$data))-variograma
# Matriz C_ij
C.ij<-covariograma[-c(3,5),-c(3,5)]
# Vector C_i0
C.i0<-covariograma[-c(3,5),5]
# Pesos lambda
lambda<-ginv(C.ij)%*%C.i0
# Datos sin los NA's
datossin<-datos[-c(3,5)]
# Estimación
t(lambda)%*%datossin
if (!require(geoR)){install.packages("geoR");library(geoR)}
if (!require(gstat)){install.packages("gstat");library(gstat)}
if (!require(MASS)){install.packages("MASS");library(MASS)}
if (!require(ade4)){install.packages("ade4");library(ade4)}
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid,color = "red",xlab="Coordenadas X",ylab = "Coordenadas Y")
plot(grid,col = "red",xlab="Coordenadas X",ylab = "Coordenadas Y")
plot(grid,fill = "red",xlab="Coordenadas X",ylab = "Coordenadas Y")
plot(grid, pch = 15, col = "red", xlab="Coordenadas X", ylab = "Coordenadas Y",
title = "Enmallado de Coordenadas X, Y")
plot(grid, col = "red", xlab="Coordenadas X", ylab = "Coordenadas Y",
title = "Enmallado de Coordenadas X, Y")
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid, pch = 15,col = "red", xlab="Coordenadas X", ylab = "Coordenadas Y")
title("Enmallado de Coordenadas X, Y")
distancia<-dist(grid)
distancia<-as.matrix(distancia)
datos <- c(12,14,NA,15,NA,14,10,12,13)
coordenadas<-cbind(grid[,1],grid[,2],datos)
colnames(coordenadas)<-c("X","Y","Datos")
coordenadas <- as.geodata(coordenadas,coords=1:2,var=3)
plot(coordenadas)
variog_exp<-2.81*(1-exp(-distancia/2))
covariog_exp<-var(na.omit(coordenadas$data))-variograma_exp
covariog_exp<-var(na.omit(coordenadas$data))-variog_exp
Mat_C_ij<-covariog_exp[-c(3,5),-c(3,5)]
Vec_C_i0<-covariog_exp[-c(3,5),5]
lambda<-ginv(Mat_C_ij)%*%Vec_C_i0
datos_sin_NA<-datos[-c(3,5)]
z_est <- t(lambda)%*%datossin
z_est <- t(lambda)%*%datos_sin_NA
print(z_est)
library (ade4)
ozone <- read.table("https://stats.idre.ucla.edu/stat/r/faq/ozone.csv", sep=",", header=T)
ozone
head(ozone, n=10)
summary(ozone)
# Map of stations
LA <- read.table ("LA.txt", head=TRUE)
# Map of stations
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
LA <- read.table ("LA.txt", head=TRUE)
plot(LA$Longitude, LA$Latitude, xlab="Longitude", ylab="Latitude",
type="l", col=4, lwd=2, xlim=c(-119, -116), main = "Stations in the Los Angeles area ")
points(ozone$Lon, ozone$Lat, col=2, pch=16,
main="Location of Ozone monitoring stations in Los Angeles",
xlab="Longitude", ylab="Latitude")
if (!require(ade4)){install.packages("ade4");library(ade4)}
if (!require(readr)){install.packages("readr");library(readr)}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
plot(temp[,2], temp[,1], xlab="Longitud", ylab="Latitud",
type="l", col=4, lwd=2, xlim=c(-119, -116), main = "Estaciones en Bogotá")
plot(temp[,2], temp[,1], xlab="Longitud", ylab="Latitud",
type="l", col=4, lwd=2, main = "Estaciones en Bogotá")
points(temp[,2], temp[,1], col=2, pch=16,
main="Estaciones de Monitoreo de Temperatura en Bogotá",
xlab="Longitud", ylab="Latitud")
est <- read.csv("CNE_IDEAM.csv", sep=",", header=T)
if (!require(readxl)){install.packages("readxl");library(readxl)}
est <- read.csv("CNE_IDEAM.csv", sep=",", header=T)
est <- read_excel("CNE_IDEAM.xls", col_names = TRUE)
View(est)
est<-est[,c(1,2,9:12)]
if (!require(dplyr)){install.packages("dplyr");library(dplyr)}
View(est)
est_1 %>% filter(est,Departamento="Bogota")
est_1 %>% est %>% filter(est,Departamento="Bogota")
est_1 <- est %>% filter(est,Departamento="Bogota")
est_1 <- est %>% filter(est,Departamento=="Bogota")
est_1 <- est %>% filter(est,Departamento == "Bogota")
est <- read_excel("CNE_IDEAM.xls", col_names = TRUE)
est<-est[,c(2,9:12)]
est_1 <- est %>% filter(est,Departamento == "Bogota")
est <- read_excel("CNE_IDEAM.xls", col_names = TRUE)
est<-est[,c(9:12)]
est_1 <- est %>% filter(est,Departamento == "Bogota")
est[,9:10] <- as.numeric(est[,9:10])
est <- read_excel("CNE_IDEAM.xls", col_names = TRUE)
est<-est[,c(9:12)]
est[,1:2] <- as.numeric(est[,1:2])
est_1 <- est %>% filter(Departamento == "Bogota")
View(est)
est_1 <- est %>% filter(est[,3] == "Bogota")
View(est)
est <- read_excel("CNE_IDEAM.xls", col_names = TRUE)
# Seleccionar las columnas 9 a 12
est <- est[, 9:12]
# Convertir las primeras dos columnas a tipo numérico, manejando valores faltantes
est[, 1:2] <- lapply(est[, 1:2], function(x) as.numeric(as.character(x)))
# Filtrar las filas donde el Departamento sea "Bogota"
est_1 <- est %>% filter(Departamento == "Bogota")
# Filtrar las filas donde el Departamento sea "Bogota"
est_1 <- est %>% filter(est[,3] == "Bogota")
View(est_1)
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
apply(est_1,2,missings)
plot(est_1[,1], est_1[,2], xlab="Longitud", ylab="Latitud",
type="l", col=4, lwd=2, main = "Estaciones en Bogotá")
plot(est_1[, 1], est_1[, 2], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá")
plot(est_1[, 2], est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá")
View(est_1)
stripchart(list(est_1[, 2], est_1[, 1]), method = "stack",
xlab = c("Longitud", "Latitud"), ylab = "Densidad", main = "Distribución de Longitud y Latitud")
stripchart(est_1[, 1], method = "stack", xlab = "Longitud", ylab = "Densidad", main = "Distribución de Longitud")
plot(x=est_1[, 2],y= est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá")
View(est_1)
plot(x = est_1[, 1], y = est_1[, 2], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá")
plot(x = est_1[, 1], y = est_1[, 2], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(4, 5))
plot(x = est_1[, 2], y = est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(4, 5))
plot(x = est_1[, 2], y = est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(-90, 90))
plot(x = est_1[, 2], y = est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(4.5, 5))
points(temp[,2], temp[,1], col=2, pch=16,
main="Estaciones de Monitoreo de Temperatura en Bogotá",
xlab="Longitud", ylab="Latitud")
plot(x = est_1[, 2], y = est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(-90, 90))
x11()
plot(x = est_1[, 2], y = est_1[, 1], xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá", ylim = c(-90, 90))
plot(x = est_1$LONGITUD, y = est_1$LATITUD, xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá")
points(temp[,2], temp[,1], col=2, pch=16,
main="Estaciones de Monitoreo de Temperatura en Bogotá",
xlab="Longitud", ylab="Latitud")
plot(x = est_1$LONGITUD, y = est_1$LATITUD, xlab = "Longitud", ylab = "Latitud",
type = "l", col = 4, lwd = 2, main = "Estaciones en Bogotá",xlim = c(-74.2,-74.06))
