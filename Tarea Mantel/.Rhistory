<<<<<<< Updated upstream
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
ruleta<-c("Argentina","Brasil","Uruguay","Ecuador","Colombia","Alemania",
"Italia","España","Francia","Inglaterra","Resto del mundo")
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
ruleta<-c("Argentina","Brasil","Uruguay",
"Ecuador","Colombia","Alemania",
"Portugal","España","Francia",
"Inglaterra","Resto del mundo")
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
ruleta<-c("Argentina","Brasil","Uruguay",
"Ecuador","Colombia","Alemania",
"Portugal","España","Francia",
"Inglaterra","Resto del mundo")
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
sample(ruleta, size = 1, replace = TRUE)
ruleta<-c("Argentina","Brasil","Uruguay",
"Chile","Colombia","Alemania",
"Portugal","España","Francia",
"Inglaterra","Resto del mundo")
cruces<-c("Lozano","Duitama","Anderson","Germán")
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat(cruces[i], "vs", cruces[i + 1], "\n")
}
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat(cruces[i], "vs", cruces[i + 1], "\n")
}
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat(cruces[i], "vs", cruces[i + 1], "\n")
}
?ifelse
cruces<-c("Lozano","Duitama","Anderson","Germán")
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat("Llave ", (i+1)/2,":",cruces[i], "vs", cruces[i + 1], "\n")
}
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat("Llave ", (i+1)/2,":",cruces[i], "vs", cruces[i + 1], "\n")
}
cruces<-c("Lozano","Duitama","Anderson","Germán",
"Julieta","Fofi","Ander","Cata",
"Karol","Juan Pablo","Lilis","Ana",
"Danna","Steven","John","Camilo")
cruces <- sample(cruces)
cat("Emparejamientos de semifinales:\n")
for (i in seq(1, length(cruces), by = 2)) {
cat("Llave ", (i+1)/2,":",cruces[i], "vs", cruces[i + 1], "\n")
}
primer_anho<-function(anho){
if(anho>0){
res<-(i*100)-99
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
primer_anho(20)
primer_anho<-function(anho){
if(anho>0){
res<-(anho*100)-99
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
primer_anho(20)
primer_anho(-2)
primer_anho(e)
primer_anho<-function(siglo){
if(siglo>0){
res<-(siglo*100)-99
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
siglo<-function(anho){
if(anho>0){
res<-anho%/%100
if(año%%100 != 0){
res<-res+1
}
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
siglo(1988)
siglo<-function(anho){
if(anho>0){
res<-anho%/%100
if(año%%100 != 0){
res<-res+1
}
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
siglo(1988)
siglo<-function(anho){
if(anho>0){
res<-anho%/%100
if(anho%%100 != 0){
res<-res+1
}
}else{
res<-"Ingrese un número positivo (año)"
}
return(res)
}
siglo(1988)
siglo(1999)
siglo(2000)
siglo(2001)
siglo(1901)
siglo(1900)
1988/100
1901/100
1900/100
siglo(-3)
primer_anho(-3)
primer_anho<-function(siglo){
if(siglo>0){
res<-(siglo*100)-99
}else{
res<-"Ingrese un número positivo (siglo)"
}
return(res)
}
primer_anho(-3)
siglo(1900)
primer_anho(3)
programa<-function(anho){
ssiglo<-siglo(anho)
pri_anho<-primer_anho(ssiglo)
return(c(ssiglo,pri_anho))
}
programa(1988)
programa(1988)[1]
programa(1988)[2]
cat("El año ", anho, " era del siglo ", programa(anho)[1],
" y el primer año de ese siglo fue ",programa(anho)[2])
anho<-1988
cat("El año ", anho, " era del siglo ", programa(anho)[1],
" y el primer año de ese siglo fue ",programa(anho)[2])
cat("Por favor a continuación escriba un año (positivo)
del cual usted desea saber a que siglo pertenece y
el primer año de ese siglo.")
anho<-1988
cat("El año ", anho, " era del siglo ", programa(anho)[1],
" y el primer año de ese siglo fue ",programa(anho)[2])
# PUNTO 3 ####
## Programa conversion medidas de longitud ####
conversion<-function(metros){
pies<-3.28084*metros
pulgadas<- 39.3701*metros
ctms<-100*metros
return(c(pies,pulgadas,ctms))
}
cat("Ingrese la medida (en metros) del objeto
del cual desea saber sus medidas.")
medida<-25
cat("El objeto mide ", medida," metros,",conversion(medida)[1],
" pies", conversion(medida)[2], " pulgadas y ", conversion(medida)[3],
" centímetros.")
cat("El objeto mide ", medida,"metros,",conversion(medida)[1],
"pies", conversion(medida)[2], "pulgadas y ", conversion(medida)[3],
"centímetros.")
cat("El objeto mide ", medida,"metros,",conversion(medida)[1],
"pies,", conversion(medida)[2], "pulgadas y ", conversion(medida)[3],
"centímetros.")
# PUNTO 2 ####
conversionAlas8AM<-function(cop){
num_usd<-pesos/3884.95
return(num_usd)
}
conversionAlMediodia<-function(cop){
num_usd<-conversionAlas8AM-(conversionAlas8AM*0.1)
return(num_usd)
}
# PUNTO 2 ####
conversionAlas8AM<-function(cop){
num_usd<-pesos/3884.95
return(num_usd)
}
conversionAlMediodia<-function(cop){
num_usd<-conversionAlas8AM-(conversionAlas8AM*0.1)
return(num_usd)
}
cat("Ingrese la cantidad de pesos colombianos los cuales desea saber
sus valores en dólares a las 8AM y al Mediodía.")
cop<-1360000
cat(cop,"COP son ",conversionAlas8AM(cop), "USD a las 8:00 AM y",
conversionAlMediodia(cop), "USD al medio día.")
# PUNTO 2 ####
conversionAlas8AM<-function(cop){
num_usd<-cop/3884.95
return(num_usd)
}
conversionAlMediodia<-function(cop){
num_usd<-conversionAlas8AM-(conversionAlas8AM*0.1)
return(num_usd)
}
cat("Ingrese la cantidad de pesos colombianos los cuales desea saber
sus valores en dólares a las 8AM y al Mediodía.")
cop<-1360000
cat(cop,"COP son ",conversionAlas8AM(cop), "USD a las 8:00 AM y",
conversionAlMediodia(cop), "USD al medio día.")
# PUNTO 2 ####
conversionAlas8AM<-function(cop){
num_usd<-cop/3884.95
return(num_usd)
}
conversionAlMediodia<-function(cop){
num_usd<-conversionAlas8AM(cop)-(conversionAlas8AM(cop)*0.1)
return(num_usd)
}
cat("Ingrese la cantidad de pesos colombianos los cuales desea saber
sus valores en dólares a las 8AM y al Mediodía.")
cop<-1360000
cat(cop,"COP son ",conversionAlas8AM(cop), "USD a las 8:00 AM y",
conversionAlMediodia(cop), "USD al medio día.")
library(geoR)
library (gstat)
library(MASS)
daticos<-c(12,15,10,14,12,14,13)
grid<-expand.grid(seq(0,2),seq(0,2))
plot(grid)
distancia<-dist(grid)
distancia<-as.matrix(distancia)
sigma<-var(daticos)
covarianza<-sigma-2.81*(1-exp(-distancia/2))
covarianza<-as.matrix(covarianza)
matplot(distancia,covarianza)
medias.cte<-rep(mean(daticos),9)
normal.cte<-mvrnorm(1,medias.cte,covarianza)
datoscte<-cbind(grid[,1],grid[,2],normal.cte)
x<-c(0,2,2,0,0)
y<-c(0,0,2,2,0)
datoscte.borde<-cbind(x,y)
datoscte.grid<-expand.grid(Este=seq(0,2), Norte=seq(0,2))
plot(datoscte.grid)
# Fondo - Salinidad ####
vario_fsali<-variog(coords=Fondo[,c("X","Y")],data=Fondo$Sali,uvec=seq(0,1000,length=50),estimator.type="class")
# Cargar datos
Fondo <- read_excel("https://github.com/gcvasquezh/Estadistica-Espacial-Talleres/raw/main/Fondo.xlsx")
library(readxl)
# Cargar datos
Fondo <- read_excel("https://github.com/gcvasquezh/Estadistica-Espacial-Talleres/raw/main/Fondo.xlsx")
# Cargar datos
Fondo <- read_excel("C:/Users/gcvh2/Documents/UNAL/8. 2024 -1S/Estadística Espacial/Estadistica-Espacial-Talleres/Fondo.xlsx")
# Cargar datos
Fondo <- read_excel("C:/Users/gcvh2/Documents/UNAL/8. 2024 -1S/Estadística Espacial/Estadistica-Espacial-Talleres/Taller 13 de Marzo/Fondo.xlsx")
View(Fondo)
coordenadas<-cbind(c(1,2,1,3,1,2,3),c(1,2,2,2,3,3,3),c(12,14,15,14,10,12,13))
View(coordenadas)
colnames(coordenadas)<-c("X","Y","Datos")
View(coordenadas)
vario_fsali<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas$Datos,uvec=seq(0,1000,length=50),estimator.type="class")
vario_fsali<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[3],uvec=seq(0,1000,length=50),estimator.type="class")
vario_fsali<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[,3],uvec=seq(0,1000,length=50),estimator.type="class")
plot(vario_fsali)
vario_toy<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[,3],uvec=seq(0,1000,length=50),estimator.type="class")
plot(vario_toy)
lineal<-variofit(vario_toy,ini=c(sigmasq=1000,phi=100),fix.nugget=FALSE,cov.model="linear")
pepita<-lineal$nugget
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
rango<-summary(lineal)$estimated.pars[3]
vario_toy<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[,3],estimator.type="class")
plot(vario_toy)
lineal<-variofit(vario_toy,ini=c(sigmasq=1000,phi=100),fix.nugget=FALSE,cov.model="linear")
pepita<-lineal$nugget
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
rango<-summary(lineal)$estimated.pars[3]
datoscte.kc<-krige.conv(datoscte, loc=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
?krige.conv
vario_toy<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[,3],estimator.type="class")
plot(vario_toy)
lineal<-variofit(vario_toy,ini=c(sigmasq=var(daticos),phi=100),fix.nugget=FALSE,cov.model="linear")
pepita<-lineal$nugget
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
rango<-summary(lineal)$estimated.pars[3]
datoscte.kc<-krige.conv(datoscte, loc=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
lineal<-variofit(vario_toy,ini=c(sigmasq=var(daticos),phi=1),fix.nugget=FALSE,cov.model="linear")
pepita<-lineal$nugget
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
rango<-summary(lineal)$estimated.pars[3]
datoscte.kc<-krige.conv(datoscte, loc=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
datoscte.kc<-krige.conv(datoscte, coords=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
datoscte.kc<-krige.conv(datoscte, locations=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
datoscte.kc<-krige.conv(datoscte,coords = coordenadas[,c(1,2)] ,locations=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
x<-c(0,2,2,0,0)
y<-c(0,0,2,2,0)
datoscte.borde<-cbind(x,y)
datoscte.grid<-expand.grid(Este=seq(0,2,l=50), Norte=seq(0,2,l=50))
plot(datoscte.grid)
vario_toy<-variog(coords=coordenadas[,c("X","Y")],data=coordenadas[,3],estimator.type="class")
plot(vario_toy)
lineal<-variofit(vario_toy,ini=c(sigmasq=var(daticos),phi=1),fix.nugget=FALSE,cov.model="linear")
pepita<-lineal$nugget
meseta<-lineal$nugget+summary(lineal)$estimated.pars[2]
rango<-summary(lineal)$estimated.pars[3]
datoscte.kc<-krige.conv(datoscte,locations=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
datoscte
datoscte.grid
datoscte.borde
datoscte.kc<-krige.conv(datoscte,locations=datoscte.grid, bord=datoscte.borde, krige= krige.control(nugget=pepita,cov.pars=c(sigmasq=meseta, phi= rango)))
coord<-cbind(c(1,1,1,2,2,2,3,3,3),c(1,2,3,1,2,3,1,2,3),c(12,15,10,14,NA,12,NA,14,13))
coord<-cbind(c(1,1,1,2,2,2,3,3,3),c(1,2,3,1,2,3,1,2,3),c(12,15,10,14,NA,12,NA,14,13))
datoscte.kc<-krige.conv(datoscte,coords=coord[,c(1,2)],
data = coord[,3] ,locations=datoscte.grid,
bord=datoscte.borde, krige= krige.control(nugget=pepita,
cov.pars=c(sigmasq=meseta, phi= rango)))
View(datoscte)
datoscte.kc<-krige.conv(datoscte,coords=datoscte[,c(1,2)],
data = datoscte[,3] ,locations=datoscte.grid,
bord=datoscte.borde, krige= krige.control(nugget=pepita,
cov.pars=c(sigmasq=meseta, phi= rango)))
library (ade4)
library(readr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp <- read.csv("temperatura.csv", sep=",", header=T)
read.csv("temperatura.csv", sep=",", header=T)
temp <- read.csv("C:/Users/gcvh2/Documents/UNAL/8. 2024 -1S/Estadística Espacial/Estadistica-Espacial-Talleres/Tarea Mantel/temperatura.csv", sep=",", header=T)
temp <- read.csv("C:\\Users\\gcvh2\\Documents\\UNAL\\8. 2024 -1S\\Estadística Espacial\\Estadistica-Espacial-Talleres\\Tarea Mantel\\temperatura.csv", sep=",", header=T)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp <- read.csv("temperatura.csv", sep=",", header=T)
temp
View(temp)
temp<-temp[,c(3,4,18)]
View(temp)
sapply(temp, is.na, 2)
apply(temp,2,sum(is.na(x)))
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
apply(temp,2,sum(is.na(x)))
apply(temp,2,sum(is.na(temp)))
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,sum(missings)
apply(temp,2,sum(missings))
apply(temp,2,sum(missings))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 9999)
res
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
coord_dists
View(temp)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library (ade4)
library(readr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 9999)
library (ade4)
library(readr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
tictoc::tic()
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 1000)
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
tictoc::tic()
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 1000)
tictoc::toc()
res
plot(res, xlab="M", main="Montecarlo distribution")
tictoc::tic()
res2<-mantel.rtest(coord_dists, alter=two-sided, valor_dists, nrepet = 1000)
library (ade4)
library(readr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
=======
library(fable)
library(cowplot)
library(astsa)
library(TSstudio)
library(fabletools)
library(TSA)
library(readxl)
PIB3 <- read_excel("C:/Users/ander/OneDrive - Universidad Nacional de Colombia/Documentos/(2024-01) Octavo Semestre/Series de Tiempo Univariadas/Proyecto/1.4 PIB_Precios constantes grandes ramas de actividades economicas_trimestral_V2.xlsx", range = "AS18:AS93", col_names = FALSE)
PIB3TS <- ts(PIB3, start = c(2005, 1), end = c(2023, 4), frequency = 4)
#Convirtiendo los datos originales en objeto serie de tiempo(ts)
plot_ly( x = time(PIB3TS), y = PIB3TS, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral en Colombia',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
acf(PIB3TS,lag.max = length(PIB3TS))
Lambda<-BoxCox.lambda(PIB3TS, method ="loglik", lower = -3, upper = 3)#Encontrando el valor de Lambda
Lambda
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))
summary(fitLM <- lm(PIB3TS~time(PIB3TS), na.action=NULL))#Creando un modelo de regresión lineal
plot(PIB3TS, ylab="PIB trimestral en Colombia",xlab="Trimestre")
abline(fitLM,col = "red")
PIB3NoLM=PIB3TS-predict(fitLM)#Eliminando la tendencia
plot_ly( x = time(PIB3NoLM), y = PIB3NoLM, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB trimestral en Colombia con tendencia lineal extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
indice1=as.Date(as.yearmon(tk_index(PIB3TS)))#Convirtiendo en fecha el indice de DesempleoTSBox, deja como primero de enero cada fecha
indice1.1=yearmon(as.yearmon(tk_index(PIB3TS)))#Dejando esa fecha solo como año y mes
## Haciendo el objeto tsibble
df=data.frame(Fecha=indice1,PIB=as.matrix(PIB3TS))
colnames(df)[2]<-"PIB"
PIB3TSibble=as_tsibble(df)
PIB3TSibble
pib3TSibble <- tsibble(
periodo = seq(as.Date("2005-01-01"), as.Date("2023-12-01"), by = "3 months"),
valor = PIB3
)
####Primera aproximación del ajuste STL
df%>%timetk::plot_time_series(Fecha, PIB,
.interactive = TRUE,
.plotly_slider = TRUE)
#Creando una nueva columna con los datos ajustados por una regresión STL de grado 2 y utilizando el 20% de los datos, entre más pequeño, la curva es menos suave
###Ajuste STL moviendo los parámetros
df%>%mutate(PIBmod=smooth_vec(PIB,span = 0.1, degree = 2))%>%
ggplot(aes(Fecha, PIB)) +
geom_line() +
geom_line(aes(y = PIBmod), color = "red")
STLextra<-PIB3TS-smooth_vec(PIB3TS,span = 0.1, degree = 2)
plot_ly( x = time(STLextra), y = STLextra, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral con tendencia STL extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
tsibblePIB<-as_tsibble(PIB3TS)#Creando el objeto tsibble del PIB
tsibblePIB
tsibblePIB %>%
model(
STL(value ~ trend() +
season(window = "periodic"),
robust = TRUE)) %>%
components() %>%
autoplot()
DiferenciaOrd<-diff(PIB3TS)
plot_ly( x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB sin tendencia(Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
PIBcomProm=decompose(PIB3TS)
plot(PIBcomProm)
ExtraProm=PIB3TS-PIBcomProm$trend
plot_ly( x = time(ExtraProm), y = ExtraProm, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB con tendencia extraída (Promedio móvil)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
acf(PIB3TS,lag.max = length(PIB3TS))
par(mfrow = c(2, 2))
acf(PIB3NoLM,lag.max =length(PIB3NoLM),main="Autocorrelación serie sin tendencia lineal")
acf(STLextra,lag.max =length(STLextra),main="Autocorrelación serie sin tendencia STL")
acf(DiferenciaOrd,lag.max =length(DiferenciaOrd),main="Autocorrelación serie sin tendencia\npor diferencia ordinaria")
acf(ExtraProm[3:74],lag.max =length(ExtraProm[3:74]),main="Autocorrelación serie sin tendencia\npor promedio móvil")
#El gráfico de retardos se realiza con la serie con tendencia extraída
#Tendencia STL extraída
par(mar = c(3,2,3,2))
lag1.plot(STLextra, 4,corr=T)
#Tendencia extraída por diferencia ordinaria
par(mar = c(3,2,3,2))
lag1.plot(DiferenciaOrd, 4,corr=T)
#Tendencia extraída por promedio móvil
par(mar = c(3,2,3,2))
lag1.plot(ExtraProm[3:74], 4,corr=T)
#Tendencia STL extraída
TSstudio::ts_heatmap(STLextra,title = "Mapa de Calor - PIB en Colombia (STL)")
#Tendencia extraída por promedio móvil
TSstudio::ts_heatmap(ExtraProm,title = "Mapa de Calor - PIB en Colombia(Promedio móvil)")
#Tendencia extraída por diferencia ordinaria
TSstudio::ts_heatmap(DiferenciaOrd,title = "Mapa de Calor - PIB en Colombia(Diferencia Ordinaria)")
monthplot(STLextra,main="Subseries(STL)")
monthplot(ExtraProm,main="Subseries(Promedio móvil)")
monthplot(DiferenciaOrd,main="Subseries(Diferencia Ordinaria)")
tsibblePIB <- tsibblePIB %>%
mutate(index = as.Date(index))
tsibblePIB<-tsibblePIB%>%mutate(Diferencia=value-lag(value))
tsibblePIB %>%
na.omit() %>%
plot_seasonal_diagnostics(.date_var = index, .value = Diferencia, .feature_set = c("quarter"), .geom = "boxplot")
ggplot(tsibblePIB %>%na.omit()|>
mutate(
Trimestre = str_c("Trimestre ", as.character(lubridate::quarter(index)))
), aes(x = Diferencia)) +
geom_density(aes(fill = Trimestre)) +
ggtitle("LosPass - Estimación de la densidad vía Kernel por trimestre") +
facet_grid(rows = vars(as.factor(Trimestre)))
#STL
PeriodgramadTra1=spectrum(as.numeric(STLextra),log='no')
ubicacion1=which.max(PeriodgramadTra1$spec)
#Promedio móvil
PeriodgramadTra2=spectrum(as.numeric(ExtraProm[3:74]),log='no')
ubicacion2=which.max(PeriodgramadTra2$spec)
#Diferencia ordinaria
PeriodgramadTra3=spectrum(as.numeric(DiferenciaOrd),log='no')
ubicacion3=which.max(PeriodgramadTra3$spec)
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie con tendencia STL extraída es: %s",PeriodgramadTra1$freq[ubicacion1])
sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodgramadTra1$freq[ubicacion1])
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie con tendencia extraída por promedio móvil es: %s",PeriodgramadTra2$freq[ubicacion2])
sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodgramadTra2$freq[ubicacion2])
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie con tendencia extraída por diferencia ordinaria es: %s",PeriodgramadTra3$freq[ubicacion3])
sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodgramadTra3$freq[ubicacion3])
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
library(magrittr)
# Corregir el código
Modelo_serie_diff <- diff_tsibble %>%
fable::ARIMA(value ~ fourier(K = 2) + pdq(order = c(0, 0, 0)) + PDQ(order = c(0, 0, 0)))
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
library(magrittr)
# Corregir el código
Modelo_serie_diff <- diff_tsibble %>%
fable::ARIMA(value ~ fourier(K = 2) + pdq(order = c(0, 0, 0)) + PDQ(order = c(0, 0, 0)))
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff <- diff_tsibble %>%
fable::ARIMA(value ~ fourier(K = 2) + pdq(order = c(0, 0, 0)) + PDQ(order = c(0, 0, 0)))
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_pib~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_pib,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#### Varios modelos la mismo tiempo
ajuste_final_models<-diff_tsibble%>%model(
`Fourier1pibdiff`=ARIMA(logdiff_pib~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier2pibdiff`=ARIMA(logdiff_pib~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier3pibdiff`=ARIMA(logdiff_pib~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`DummyPIBdiff`=ARIMA(logdiff_pib~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
library(tidyverse)
library(tsibble)
library(fable)
library(fabletools)
library(TSA)
###Variables Dummy y Armónicos
forecast::seasonaldummy(PIB3TS)
Armonicos=TSA::harmonic(PIB3TS, m = 1)
###Armónicos
forecast::fourier(PIB3TS,K=1)
tiempo=1
j=1
sin(2*pi*tiempo*j/4)
cos(2*pi*tiempo*j/4)
###Gráfica de los armónicos
harmonics = fourier(PIB3TS, K = 2)
harmonics
par(mar = c(1,4,1,1), mfrow = c(6,2))
for(i in 1:ncol(harmonics)){
plot(harmonics[,i], type = 'l', xlab = "Time", ylab = colnames(harmonics)[i])
}
par(mar = rep(4, 4), mfrow=c(1,1))
diff_tsibble<-tsibblePIB|>mutate(logdiff_PIB=difference(log(value)))|>select(logdiff_PIB)
###Explore diferentes valores de K
# Corregir el código
Modelo_serie_diff<-diff_tsibble|>model(
`Fourier1PIBdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado1<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
real_ajustado1 %>%
autoplot() +
geom_line(data=real_ajustado1,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=real_ajustado1,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#####Ajuste Dummy
Modelo_serie_diff_Dummy<-diff_tsibble|>model(
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
Modelo_serie_diff_Dummy<-diff_tsibble%>%left_join(fitted(Modelo_serie_diff,by=index))%>%select(-.model)
Modelo_serie_diff_Dummy %>%
autoplot() +
geom_line(data=Modelo_serie_diff_Dummy,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_Dummy,aes(y=.fitted,colour="ajustado"))+
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustado" = "red"))
#### Varios modelos la mismo tiempo
ajuste_final_models<-diff_tsibble%>%model(
`Fourier1pibdiff`=ARIMA(logdiff_PIB~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier2pibdiff`=ARIMA(logdiff_PIB~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`Fourier3pibdiff`=ARIMA(logdiff_PIB~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),
`DummyPIBdiff`=ARIMA(logdiff_PIB~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
glance(ajuste_final_models)
ajuste_final_models %>%
select(Fourier1pibdiff)%>%coef()
Modelo_serie_diff_models<-diff_tsibble%>%left_join(fitted(ajuste_final_models)|>group_by(.model)%>%
pivot_wider(names_from = .model, values_from = .fitted))
Modelo_serie_diff_models %>%
autoplot() +
geom_line(data=Modelo_serie_diff_models,aes(y=logdiff_PIB,colour="real"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier1pibdiff,colour="ajustadoFourier1"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier2pibdiff,colour="ajustadoFourier2"))+
geom_line(data=Modelo_serie_diff_models,aes(y=Fourier3pibdiff,colour="ajustadoFourier3"))+
geom_line(data=Modelo_serie_diff_models,aes(y=DummyPIBdiff,colour="ajustadoDummy")) +
scale_color_manual(name = "real/ajustado", values = c("real" = "black", "ajustadoFourier1" = "red","ajustadoFourier2" = "blue","ajustadoFourier3"="green","ajustadoDummy"="yellow"))
STLextra<-PIB3TS-smooth_vec(PIB3TS,span = 0.1, degree = 2)
library(plotly)
library(forecast)
library(MASS)
library(tidyverse)
library(lubridate)
library(timetk)
library(tibble)
library(zoo)
library(tsibble)
library(feasts)
library(fable)
library(cowplot)
library(astsa)
library(TSstudio)
library(fabletools)
library(TSA)
library(readxl)
PIB3 <- read_excel("C:/Users/ander/OneDrive - Universidad Nacional de Colombia/Documentos/(2024-01) Octavo Semestre/Series de Tiempo Univariadas/Proyecto/1.4 PIB_Precios constantes grandes ramas de actividades economicas_trimestral_V2.xlsx", range = "AS18:AS93", col_names = FALSE)
PIB3TS <- ts(PIB3, start = c(2005, 1), end = c(2023, 4), frequency = 4)
#Convirtiendo los datos originales en objeto serie de tiempo(ts)
plot_ly( x = time(PIB3TS), y = PIB3TS, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral en Colombia',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
acf(PIB3TS,lag.max = length(PIB3TS))
Lambda<-BoxCox.lambda(PIB3TS, method ="loglik", lower = -3, upper = 3)#Encontrando el valor de Lambda
Lambda
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))9
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))9
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50)))
MASS::boxcox(lm(PIB3TS ~ 1),seq(-3, 3, length = 50))
summary(fitLM <- lm(PIB3TS~time(PIB3TS), na.action=NULL))#Creando un modelo de regresión lineal
plot(PIB3TS, ylab="PIB trimestral en Colombia",xlab="Trimestre")
abline(fitLM,col = "red")
PIB3NoLM=PIB3TS-predict(fitLM)#Eliminando la tendencia
plot_ly( x = time(PIB3NoLM), y = PIB3NoLM, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB trimestral en Colombia con tendencia lineal extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
indice1=as.Date(as.yearmon(tk_index(PIB3TS)))#Convirtiendo en fecha el indice de DesempleoTSBox, deja como primero de enero cada fecha
indice1.1=yearmon(as.yearmon(tk_index(PIB3TS)))#Dejando esa fecha solo como año y mes
## Haciendo el objeto tsibble
df=data.frame(Fecha=indice1,PIB=as.matrix(PIB3TS))
colnames(df)[2]<-"PIB"
PIB3TSibble=as_tsibble(df)
PIB3TSibble
pib3TSibble <- tsibble(
periodo = seq(as.Date("2005-01-01"), as.Date("2023-12-01"), by = "3 months"),
valor = PIB3
)
####Primera aproximación del ajuste STL
df%>%timetk::plot_time_series(Fecha, PIB,
.interactive = TRUE,
.plotly_slider = TRUE)
#Creando una nueva columna con los datos ajustados por una regresión STL de grado 2 y utilizando el 20% de los datos, entre más pequeño, la curva es menos suave
###Ajuste STL moviendo los parámetros
df%>%mutate(PIBmod=smooth_vec(PIB,span = 0.1, degree = 2))%>%
ggplot(aes(Fecha, PIB)) +
geom_line() +
geom_line(aes(y = PIBmod), color = "red")
STLextra<-PIB3TS-smooth_vec(PIB3TS,span = 0.1, degree = 2)
plot_ly( x = time(STLextra), y = STLextra, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB Trimestral con tendencia STL extraída',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
tsibblePIB<-as_tsibble(PIB3TS)#Creando el objeto tsibble del PIB
tsibblePIB
tsibblePIB %>%
model(
STL(value ~ trend() +
season(window = "periodic"),
robust = TRUE)) %>%
components() %>%
autoplot()
DiferenciaOrd<-diff(PIB3TS)
plot_ly( x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB sin tendencia(Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
DiferenciaOrd<-diff(PIB3TS)
plot_ly( x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines',color=I("red")) %>%
layout(title = 'PIB sin tendencia(Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
# Carga la biblioteca
library(gstat)
library(readr)
temp <- read.csv("C:/Users/ander/Downloads", sep=",",header=T)
library(reaxl)
temp <- read_excel("C:/Users/ander/Downloads", sep=",",header=T)
library(readxl)
temp <- read_excel("C:/Users/ander/Downloads", sep=",",header=T)
temp <- read_excel("C:/Users/ander/Downloads")
library (ade4)
library(readr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
>>>>>>> Stashed changes
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
tictoc::tic()
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 1000)
tictoc::toc()
res
plot(res, xlab="M", main="Montecarlo distribution")
# Taller Estadística Espacial - Geoestadística
# Nombre: John Anderson Guarin Lopez - German Camilo Vasquez Herrera
if (!require(ade4)){install.packages("ade4");library(ade4)}
if (!require(readr)){install.packages("readr");library(readr)}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Taller Estadística Espacial - Test de Mantel
# Nombre: John Anderson Guarin Lopez - German Camilo Vasquez Herrera
if (!require(ade4)){install.packages("ade4");library(ade4)}
if (!require(readr)){install.packages("readr");library(readr)}
if (!require(rstudioapi)){install.packages("rstudioapi");library(rstudioapi)}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
tictoc::tic()
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 1000)
tictoc::toc()
# Taller Estadística Espacial - Test de Mantel
# Nombre: John Anderson Guarin Lopez - German Camilo Vasquez Herrera
if (!require(ade4)){install.packages("ade4");library(ade4)}
if (!require(readr)){install.packages("readr");library(readr)}
if (!require(rstudioapi)){install.packages("rstudioapi");library(rstudioapi)}
if (!require(tictoc)){install.packages("tictoc");library(tictoc)}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
temp<-read.csv("temperatura.csv", sep=",", header=T)
temp<-temp[,c(3,4,18)]
missings <- function(x) return(sum(is.na(x)))
apply(temp,2,missings)
# Mantel test
?mantel.rtest
coord_dists <- dist(cbind(temp$Longitud, temp$Latitud))
valor_dists <- dist(temp$Valor)
tictoc::tic()
res<-mantel.rtest(coord_dists, valor_dists, nrepet = 1000)
tictoc::toc()
res
plot(res, xlab="M", main="Montecarlo distribution")
